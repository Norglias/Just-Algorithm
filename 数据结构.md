## 数据结构

### 1.链表操作

##### 例题: 洛谷P12085

![image-20251205191931955](C:\Users\20421\Desktop\LEARN\算法题型小记录.assets\image-20251205191931955.png)



可以使用STL中的set型, 可以自动排序, 并且需要嵌套pair型以记录下标

```c++
set<pair<ll,int>>s;
```



下面是用集合加pair的实现, 但是会有一个点TLE

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=500010;

string word;

long long a[maxn];
int l[maxn],r[maxn];

int main()
{
    int n,k;
    set<pair<ll,int>>s;
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        s.insert({a[i],i});
        l[i]=i-1;
        r[i]=i+1;
    }
    r[0]=1;
    l[n+1]=n;

    while (k--)
    {
        pair<ll,int>min_n=*s.begin();
        s.erase(s.begin());

        ll val=min_n.first;
        int idx=min_n.second;

        int le_n=l[idx],ri_n=r[idx]; 

        if(le_n!=0)
        {
            s.erase({a[le_n],le_n});
            a[le_n]+=val;
            s.insert({a[le_n],le_n});
        }
        if(ri_n!=n+1)
        {
            s.erase({a[ri_n],ri_n});
            a[ri_n]+=val;
            s.insert({a[ri_n],ri_n});
        }
        r[le_n]=ri_n;
        l[ri_n]=le_n;
    }
    int curr = r[0];
    bool first = true;
    while (curr != n + 1) {
        if (!first) cout<<" ";
        cout << a[curr];
        curr = r[curr];
        first = false;
    }
    
    return 0;
}
```

需要用小根堆实现, 才能避免tle



### 2.前缀和 与 差分数组

#### 一维线性

> 如果我们有一组数（个数小于等于一千万），并且有一大堆询问——给定区间l、r,求l、r之间所有数之和（询问个数小于等于一千万）
>
> 这种应该怎么做呢?

> 在上述问题, 我们可以使用前缀和思想: 
>
> 前缀和数组 $S$ 是由原数组 $A$ 派生出来的。$S$ 中的第 $i$ 个元素 $S[i]$ 存储的是原数组 $A$ 中**从起始元素到第 $i$ 个元素的所有元素之和**

**前缀和:**

构造数组`sum[i]`存储数组前n项的和: 

```c++
for(int i=1;i<=n;i++)
{
    cin>>a[i];
    sum[i]=sum[i-1]+a[i];
}
```

下一步该如何计算给定区间内的所有数字之和呢

```c++
for(int i=1;i<=q;i++)
{
    cin>>le>>ri;
    cout<<sum[ri]-sum[le-1];
}
```



**差分数组:**

算是前缀和的逆运算:

**我们给定前i个数相邻两个数的差（1<=i<=n）,求每一项a[i]（1<=i<=n）**

给定 差数组 `diff[ ]`

```c++
for(int i=0;i<=n;i++)
{
    cin>>diff[i];
    a[i]=diff[i]+a[i-1];	
}
```



**实例**

比如对一个数组进行任意连续区间进行批量的、重复的增减操作

可以这样用:

```c++
for(int i=1;i<=n;i++)//把每一项之间的差用diff表示出来
{
    diff[l[i]]+=num[i]; //num表示增量
    diff[r[i]+1]-=num[i]; //使用r[i]+1表示清除后缀r右边的增量
}
//使用前缀和, 在一次遍历里完成对原数组的操作
for(int i=1;i<=length;i++)
{
    a[i]=a[i-1]+diff[i];
}
```



#### 二维平面

##### 前缀和公式

现在设 $a[i][j]$ 为第 $i$ 行第 $j$ 列的数，$s[i][j]$ 为 $(1, 1)$ 至 $(i, j)$ 的矩阵中的所有数的和，那么：

$$s[x][y] = a[x][y] + s[x - 1][y] + s[x][y - 1] - s[x - 1][y - 1]$$

利用**容斥原理**可以理解上式。

> 如:
>
> $$ \begin{bmatrix} 3 & 7 & 2 \\ 10 & 5 & 8 \\ 4 & 9 & 1  \end{bmatrix}$$
>
> 计算最后一个元素时, 可代入公式看一下



当需要计算某个$$n \times n $$区间内的总和时

可先把上述前缀和数列加出来

然后使用公式:

$$sum = s[x][y] - s[x - n][y] - s[x][y - n] + s[x - n][y - n]$$





##### 差分数组

关于差分数组的预处理, 和一维的差别不大, 只要考虑四个角的变化就行了

```c++
diff[stx][sty]++;
diff[stx][eny+1]--;
diff[enx+1][sty]--;
diff[enx+1][eny+1]++;
```

> **帮助理解的实例**
>
> 假设我们有一个 $3 \times 3$ 的全 0 矩阵，现在我们要执行一个操作：
>
> 将左上角 $(1, 1)$ 到右下角 $(2, 2)$ 的矩形区域全部加 $5$。
>
> ------
>
> **第一步：差分数组的操作 (Update)**
>
> 根据公式 $d[x_1][y_1] += v, d[x_1][y_2+1] -= v, d[x_2+1][y_1] -= v, d[x_2+1][y_2+1] += v$：
>
> - $d[1][1] \leftarrow +5$
> - $d[1][3] \leftarrow -5$ （即 $y_2+1=3$）
> - $d[3][1] \leftarrow -5$ （即 $x_2+1=3$）
> - $d[3][3] \leftarrow +5$ （即 $x_2+1=3, y_2+1=3$）
>
> 此时，**差分数组 $d$** 如下（未列出的位置为 0）：
>
> |       | **1**  | **2** | **3**  |
> | ----- | ------ | ----- | ------ |
> | **1** | **+5** | 0     | **-5** |
> | **2** | 0      | 0     | 0      |
> | **3** | **-5** | 0     | **+5** |
>
> ------
>
> **第二步：利用容斥原理求前缀和还原 (Recover)**
>
> 我们使用公式 $s[i][j] = d[i][j] + s[i-1][j] + s[i][j-1] - s[i-1][j-1]$ 逐个计算。
>
> 1. 计算 $s[1][1]$:
>
>    $s[1][1] = d[1][1] + s[0][1] + s[1][0] - s[0][0] = 5 + 0 + 0 - 0 = \mathbf{5}$
>
> 2. 计算 $s[1][2]$:
>
>    $s[1][2] = d[1][2] + s[0][2] + s[1][1] - s[0][1] = 0 + 0 + 5 - 0 = \mathbf{5}$
>
> 3. 计算 $s[1][3]$ (进入减值区):
>
>    $s[1][3] = d[1][3] + s[0][3] + s[1][2] - s[0][2] = -5 + 0 + 5 - 0 = \mathbf{0}$
>
>    (可以看到，从第 3 列开始，$+5$ 被这一列的 $-5$ 抵消了)
>
> 4. 计算 $s[2][1]$:
>
>    $s[2][1] = d[2][1] + s[1][1] + s[2][0] - s[1][0] = 0 + 5 + 0 - 0 = \mathbf{5}$
>
> 5. 计算 $s[2][2]$:
>
>    $s[2][2] = d[2][2] + s[1][2] + s[2][1] - s[1][1] = 0 + 5 + 5 - 5 = \mathbf{5}$
>
>    (注意这里的容斥：$5+5$ 之后减去重复的左上角 $5$，结果依然是 $5$)
>
> 6. 计算 $s[3][3]$ (右下角修正点):
>
>    在这个位置，上方的累加和左边的累加都已经因为之前的 $-5$ 变成了 $0$，最后的 $+5$ 确保了矩阵外围区域全部归零。
>
> ------
>
> **最终还原的矩阵结果**
>
> |       | **1** | **2** | **3** |
> | ----- | ----- | ----- | ----- |
> | **1** | **5** | **5** | 0     |
> | **2** | **5** | **5** | 0     |
> | **3** | 0     | 0     | 0     |



### 3.并查集

> 并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合,  树中的节点表示对应集合中的元素。
>
> ——摘自 [OI wiki](https://oi-wiki.org/ds/dsu/)

并查集在竞赛中最常用的实现是: 

**把一个集合抽象为一颗树**.

并且树根为该集合的**代表元素**.

**所谓并:**  就是合并元素为一个集合, 合并的实现可以将两个集合共用一个代表元素.

**所谓查:**  就是查找对应元素在哪一个集合下.



##### 查找实现

一般情况下并查集使用数组实现, 其中数组`fa[]`通常用来记录每个节点的**父节点**

最简单的查找方法就是使用递归实现

```cpp
int fa[maxn];

int find(int x)
{
    if(fa[x]==x)
    return x;
    else return find(fa[x]);
}
```

但是这样的话多次查询就比较费力了(时间复杂度$O(nm)$)

所以我们有**路径压缩优化:** (时间复杂度接近于$O(1)$)

第一次查询时, 把所有子节点的父节点**全部标记为代表元素**

这样后面的查询只要一次就行, 但是会破坏树的结构. 但在并查集中我们不关心树的结构, 只关心**代表元素**

**路径压缩优化:**

```c++
int find(int x)
{
    if(fa[x]==x)
    return x;
    else return fa[x]=find(fa[x]); //递归返回的过程中统一父节点
}
```



##### 合并实现

合并就是共用两个集合的代表元素

```c++
x=find(x),y=find(y);
if(x==y) //如果已经是同一个集合的元素, 跳过操作
continue;
fa[x]=y; //合并顺序可以任意
```



