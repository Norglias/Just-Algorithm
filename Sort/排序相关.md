## 排序相关

### 1.快速排序

快速排序的思路即是找到一个基准值

基准值左侧小于基准值的与基准值右侧大于基准值的进行交换

交换后在基准值左侧再找到一个基准值进行同理操作

即使用递归和分治的思想.

(可理解为和二分有类似)



quicksort函数实现:

```c++
int num[10050];
int n;
void sort1(int left,int right)
{
   if (left>=right)       //防止意外发生
   {
      return;
   }
   int mid=(left+right)/2;
   int i=left;
   int j=right;
   int p=num[mid];     //基准值
   while (i<=j)
   {
      while (num[i]<p) //基准值左侧代码实现
      {i++;}
      while (num[j]>p) //右侧代码实现
      {j--;}
      if (i<=j)
      {
         swap(num[i],num[j]);
         i++;j--;      //千万别忘了在交换完成后还要继续寻找
      }                //直到j跑到i的左边
   }
    //分治思想
   if (left<j)
   {
      sort1(left,j);  
   }
   if (right>i)
   {
      sort1(i,right);
   }
}
```

最简写法(都一样):

```c++
void qsort(int l,int r){
    int mid=a[(l+r)/2],i=l,j=r;
    do{while(a[i]<mid)i++;
       while(a[j]>mid)j--;
       if(i<=j){swap(a[i],a[j]);i++;j--;}
    }while(i<=j);
    if(l<j)qsort(l,j);
    if(i<r)qsort(i,r);
}
```



### 2.逆序对 (归并排序)

归并排序模板: 

```cpp
// a 数组是原数组, b 数组是临时储存结果的
inline void msort(int l,int r)
{
    int mid=(l+r)/2;
    if(l==r)
    return;
    else //二分递归,分解元素
    {
        msort(l,mid);
        msort(mid+1,n);
    }
    //下面是合并流程
    int i=l;
    int j=mid+1;
    int t=l;
    while (i<=mid&&j<=r)
    {
        if(a[i]>a[j]) //如果前面的比后面的大, 执行操作, 并且说明有逆序对
        {
            ans+=mid-i+1; //此行用来求逆序对个数
            b[t++]=a[j];
            j++;
        }
        else
        {
            b[t++]=a[i];
            i++;
        }
    }
    //下面是把剩下的较大的元素分配进去
    while (i<=mid)
    {
        b[t++]=a[i];
        ++i;
    }
    while (j<=r)
    {
        b[t++]=a[j];
        ++j;
    }
    //最后一定要把b的数据存进a里面
    for(int i=l;i<=r;i++)
    a[i]=b[i];
    return;
}
```



