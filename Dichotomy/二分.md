## 二分

### 1.二分答案(求诸如最大值的最小值)

模板:

```c++
bool check(T mid) {
    // 检查：是否存在一个解 mid 满足题目的所有条件？
    // 如果满足条件，返回 true；否则返回 false。
    // 注意：这个函数的实现是解题的关键！
    // 检查过程通常是 O(N) 或 O(N log N)
}

T binary_search_answer(T low, T high) {
    T ans = high; // 初始化答案为最差情况（最大值）
    
    while (low <= high) {
        T mid = low + (high - low) / 2; // 避免溢出的中点计算
        
        if (check(mid)) {
            // 如果 mid 满足条件 (可能更优)
            ans = mid;         // 记录当前的 mid 作为可能解
            high = mid - 1;    // 尝试寻找更小的（更优的）解
        } else {
            // mid 不满足条件，说明解太小了
            low = mid + 1;     // 必须从更大的范围中寻找
        }
    }
    return ans; // 返回找到的满足条件的最小值
}
```

即:

1. **用二分的方法枚举**
2. **枚举以判断是否成立**

**如下是一道例题: (洛谷P1182)**

![image-20251127195432251](C:\Users\20421\Desktop\LEARN\算法题型小记录.assets\image-20251127195432251.png)

代码实现如下: 

```c++
#include <bits/stdc++.h>

using namespace std;
int cnt=0;
int a[500100];
int n,m;

bool check(int t)
{
    int cur=0,ans=1;
    for (int i = 0; i < n; i++)
    {
        if(cur+a[i]>t)
        {
            cur=0;
            ans++;
        }
        cur+=a[i];
    }
    return ans<=m;
}

int erfen(int low,int high)
{
    int ans=high;
    while (low<=high)
    {
        int mid=low+(high-low)/2;
        if(check(mid))
        {
            ans=mid;
            high=mid-1;
        }
        else
        low=mid+1;
    }
    return ans;
}
int main()
{
    cin>>n>>m;
    int r=0,l;
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
        r+=a[i];
        l=max(l,a[i]);
    }
    cout<<erfen(l,r);
    return 0;
}
```



二分答案求**最大值的最小值**模板:

```c++
int erfen(int low,int high)
{
    int ans=high;
    while (low<=high)
    {
        int mid=low+(high-low)/2;
        //或者 mid=(low+high)>>1;
        if(check(mid))
        {
            ans=mid;
            high=mid-1; //尝试寻找更优解
        }
        else
        low=mid+1;
    }
    return ans;
}
```

check函数的逻辑: (其实可以用前缀和)

```c++
bool check(int t)
{
    int cur=0,ans=1;
    for (int i = 0; i < n; i++)
    {
        if(cur+a[i]>t)
        {
            cur=0;
            ans++;
        }
        cur+=a[i];
    }
    return ans<=m;
}
```



**总的逻辑就是:**

查找如果每组最大值为t时可不可以分为m组,

如果可以尝试更小一点的值看看行不行.



### 2.最长上升子序列 (二分做法)

##### 基础做法

新建一个low数组, `low[i]`表示长度为i的LIS结尾元素的最小值. 众所周知, 只要`low[i]`越小, 后面就能接更多的元素, 越有可能变得更长.

因此, 我们需要维护`low[i]`数组, 对于每一个`a[i]`, 如果`a[i]` > `low[当前最长的LIS长度]`, 就把`a[i]`接在当前最长的LIS后面.

**过程实例:**

> 有以下序列A[ ] = 1 4 7 2 5 9 10 3，求LIS长度。

我们用 B[ ] 表示 low[ ]

- A[1] = 1，把1放进B[1]，此时B[1] = 1，B[ ] = {1}，len = 1
- A[2] = 4，把4放进B[2]，此时B[2] = 4，B[ ] = {1,4}，len = 2
- A[3] = 7，把7放进B[3]，此时B[3] = 7，B[ ] = {1,4,7}，len = 3
- A[4] = 2，因为2比4小，所以把B[2]中的4替换为2，此时B[ ] = {1,2,7}，len = 3
- A[5] = 5，因为5比7小，所以把B[3]中的7替换为5，此时B[ ] = {1,2,5}，len = 3
- A[6] = 9，把9放进B[4]，此时B[4] = 9，B[ ] = {1,2,5,9}，len = 4
- A[7] = 10，把10放进B[5]，此时B[5] = 10，B[ ] = {1,2,5,9,10}，len = 5
- A[8] = 3，因为3比5小，所以把B[3]中的5替换为3，此时B[ ] = {1,2,3,9,10}，len = 5

我们可以知道, 正确的最长上升子序列应该为 {1,4,5,9,10} 或者 {1,2,5,9,10} ,所以我们可以知道 **B[ ] 所代表的不一定就是 LIS**

low[ ] 数组只是一个计数的中间工具, 但其对应的长度确实就是LIS的长度

**代码示例:**

```c++
int binary_search(int *a, int R, int x)
//二分查找，返回a数组中第一个>=x的位置 
{
    int L = 1, mid;
    while(L <= R){
        mid = (L+R) >> 1;
        if(a[mid] <= x)
            L = mid + 1;
        else 
            R = mid - 1;
    }
    return L;
}
 
int main()
{
    scanf("%d", &n);
    for(int i=1; i<=n; i++) 
    {
        scanf("%d", &a[i]); 
        low[i] = INF;   //由于low中存的是最小值，所以low初始化为INF 
    }
    low[1] = a[1]; 
    ans = 1;   //初始时LIS长度为1 
    for(int i=2; i<=n; i++)
    {
        if(a[i] > low[ans])    //若a[i]>=low[ans]，直接把a[i]接到后面 
            low[++ans] = a[i];
        else       //否则，找到low中第一个>=a[i]的位置low[j]，用a[i]更新low[j] 
            low[binary_search(low, ans, a[i])] = a[i];
    }
    printf("%d\n", ans);   //输出答案 
    return 0;
}
```



当然在我们伟大的STL中, 有内置函数可以返回low中第一个 >= a[ i ] 的位置

那就是`lower_bound()`

**纯STL实现:**

```c++
vector<int>num(maxn);
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n;cin>>n;
    for(int i=0;i<n;i++)
    cin>>num[i];
    
    vector<int>low;

    for(int x:num)
    {
        if(low.empty()||x>low.back())
        low.push_back(x);
        else
        {
            auto it=lower_bound(low.begin(),low.end(),x); //注意lower_bound返回的是地址,这里使用迭代器
            *it=x; //对应的迭代器替换为x
        }
    }
    cout<<low.size();
    return 0;
}
```

也可以这样: (感觉比上面的还难理解一点QAQ)

```cpp
int ans=0;
for(int i=1;i<=n;i++)
{
    int temp=lower_bound(low,low+ans+1,a[i])-low;
    low[temp]=a[i];
    if(ans<temp)ans=temp;
}
```



##### 拓展: 最长不上升子序列

代码稍有变动, 需要加上`greater<int>()`方法加上`upper_bound`去查找数列中第一个小于等于这个数的位置

```c++
int re_lis(int n)
{
    vector<int>low;
    for(int x:qwq)
    {
        if(low.empty()||x<=low.back())
        low.push_back(x);
        else
        {
            auto it=upper_bound(low.begin(),low.end(),x,greater<int>());
            *it=x;
        }
    }
    return low.size();
}
```



**应用: 洛谷P1020 导弹拦截**

> **题目描述**
>
> 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。
>
> 输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。
>
> **输入格式**
>
> 一行，若干个整数，中间由空格隔开。
>
> **输出格式**
>
> 两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

第一个问题就是**求最长不上升子序列长度**

而第二问就是**求最长上升子序列长度**