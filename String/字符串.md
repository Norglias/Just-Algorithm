## 字符串

### 1.字符串哈希

#### 1.进制hash

> ##### 题目描述
>
> 给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。
>

所谓字符串hash, 就是把字符串映射为一个数字, 并进行比较.

假如给定字符串 `abcd` , 我们可以将对应的位置转换为数字 `1234`

在代码中要转化为具体的数字

```cpp
inline int calc(){
	int sum=0;
	int a[]={1,1,4,5,1,4};
	for(int i=0;i<6;++i)sum=sum*10+a[i];
	return sum;
}
```

这里是十进制表达, 当然, 也可以使用其他不同的进制, 这个进制就叫 **基数 (base)** 

但我们可以想到, 如果字符串很多, 那么就有可能会溢出, 所以我们需要一个模数mod

下面就是hash的核心公式

$$\text{hashh} = \left( \sum_{i=1}^{n} s_i \cdot \text{base}^{n-i} \right) \bmod p$$

而如果模数过小, 则有可能导致数字相等而导致**哈希冲突**, 所以我们通常选择**非常大的质数**作为mod

(我们也可以用**unsigned long long**作为变量类型, 这个类型如果超过了上限会自动取模, 但保险起见加上mod还是好一点)



下面是**进制哈希**的代码实现 

```c++
#define ull unsigned long long
ull mod=212370440130137957ll;
ull hash1[maxn];

ull hhash(string a)
{
    ull ans=0,base=10;
    for(auto &x:a)
    {
        ans=(ans*base+(ull)x)%mod;
    }
    return ans;
}
int main()
{
    int n;cin>>n;
    string awa;
    for(int i=1;i<=n;i++)
    {
        cin>>awa;
        hash1[i]=hhash(awa);
    }
    sort(hash1+1,hash1+n+1);
    int cnt=1;
    for(int i=1;i<n;i++)
    {
        if(hash1[i]!=hash1[i+1])
        cnt++;
    }
    cout<<cnt;
}
```



如果我们想要取子串, 该怎么做?

类似于**前缀和**的操作, 我们可以算出各个区间对应的hash值

```cpp
ull hhh(ull h[],ull p[],int l,int r)
{
    return h[r]-h[l-1]*p[r-l+1];
}
```

h[ ]代表存储的字符串hash值, 而p代表进制数组. 因为不同位置的h[ ]值之间有**进制数差异**, 需要补全



下面是存数据的方式

```cpp
const int ppp=131;

void init(string s,ull h[],ull p[])
{
    p[0]=1;
    h[0]=0;
    for(int i=1;i<=s.length();i++)
    {
        p[i]=p[i-1]*ppp;
        h[i]=h[i-1]*ppp+s[i-1];
    }
}
```

