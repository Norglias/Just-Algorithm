## 图论

### 1.最小生成树 (MST)

> **什么是最小生成树?**
>
> 可以这样理解: 如果你有若干个点（比如城市），它们之间有一些连线（比如道路），每条线都有一个开销（权值）。**最小生成树就是指：用最小的总开销，把所有的点连通起来，且不形成环。**
>
> 所谓没有环, 就是如果有n个点, 那最多只能保留n-1个点

#### Kruskal算法

学习Kruskal算法之前, 我们需要了解如何在C++内存储一张图

图通常使用**结构体数组**实现

```c++
struct Edge
{
    int u,v,w; //起点,终点,权值(边长度)
};//edge[100010]; 这样不用STL也行
vector<Edge>edge;
```



Kruskal算法的核心思想就是把**权值从小到大排序**, 再使用**并查集**的思想判断两个点是否相连, 直到连接了n-1个边

排序判定函数: (根据权值排序)

```cpp
bool cmp(Edge a,Edge b)
{
    return a.w<b.w;
}
```

> 最小生成树板子题:
>
> **题目描述**
>
> 如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。
>
> **输入格式**
>
> 第一行包含两个整数 *N*,*M*，表示该图共有 *N* 个结点和 *M* 条无向边。
>
> 接下来 *M* 行每行包含三个整数 *X**i*,*Y**i*,*Z**i*，表示有一条长度为 *Z**i* 的无向边连接结点 *X**i*,*Y**i*。
>
> **输出格式**
>
> 如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 `orz`。

直接看代码实现:

```cpp
int fa[maxn];

struct Edge
{
    int u,v,w;
};
vector<Edge>edge;
bool cmp(Edge a,Edge b)
{
    return a.w<b.w;
}

int find(int x)
{
    if(fa[x]==x)
    return x;
    else
    return fa[x]=find(fa[x]);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++)
    fa[i]=i;
    for(int i=1;i<=m;i++) //输入数据
    {
        int u,v,w;cin>>u>>v>>w;
        edge.push_back({u,v,w});
    }
    sort(edge.begin(),edge.end(),cmp);
    int ans=0,cnt=n;
    for(auto x:edge) //遍历数组
    {
        int xu=find(x.u);
        int xv=find(x.v);
        if(xu!=xv)
        {
            fa[xu]=xv; //合并的时候千万别又忘了
            cnt--;	   //xu,xv是x.uyx.v的根节点
            ans+=x.w;
        }
        if(cnt==1)
        break;
    }
    if(cnt!=1)
    cout<<"orz";
    else
    cout<<ans;

    return 0;
}
```



#### Prim算法

> 当遇到根结点较多的树时, 就要使用Prim算法了

  **Prim的流程:**

 1. 开始将起点标记为蓝点
 2. 找一条连接**蓝点集合中一点**和白点集合中一点最短的边
 3. 将该边连接的白点加入蓝点
 4. 将该加入的蓝点所有连接的白点最短边更新
 5. 返回第二步, 直到n个点都被选入最小生成树为止

 Prim的核心思想是**找点**, 而Kruskal是**找边**.

 当遇到坐标形式的图, 就可以用Prim.

**核心算法流程 (坐标型)** 

```c++
double prim()
{
    dis[1]=0.0;
    int cur;
    double minn;
    double ans=0.0;
    //寻找距离最近的点
    for(int i=1;i<=n;i++)
    {
        cur=1;minn=1e14*1.0;
        for(int j=1;j<=n;j++)
        {
            if(!root[j]&&dis[j]<minn)
            {
                cur=j;minn=dis[j];
            }
        }
        root[cur]=true;
        ans+=dis[cur];
        //更新其他根节点到"城市联盟"的最近距离
        for(int j=1;j<=n;j++)
        {
            dis[j]=min(dis[j],distance(city[j].first,city[j].second,city[cur].first,city[cur].second));
        }
    }
    return ans;
}
```

