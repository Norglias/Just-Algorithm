## 图论

### 1.最小生成树 (MST)

> **什么是最小生成树?**
>
> 可以这样理解: 如果你有若干个点（比如城市），它们之间有一些连线（比如道路），每条线都有一个开销（权值）。**最小生成树就是指：用最小的总开销，把所有的点连通起来，且不形成环。**
>
> 所谓没有环, 就是如果有n个点, 那最多只能保留n-1个点

#### Kruskal算法

学习Kruskal算法之前, 我们需要了解如何在C++内存储一张图

图通常使用**结构体数组**实现

```c++
struct Edge
{
    int u,v,w; //起点,终点,权值(边长度)
};//edge[100010]; 这样不用STL也行
vector<Edge>edge;
```



Kruskal算法的核心思想就是把**权值从小到大排序**, 再使用**并查集**的思想判断两个点是否相连, 直到连接了n-1个边

排序判定函数: (根据权值排序)

```cpp
bool cmp(Edge a,Edge b)
{
    return a.w<b.w;
}
```

> 最小生成树板子题:
>
> **题目描述**
>
> 如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。
>
> **输入格式**
>
> 第一行包含两个整数 *N*,*M*，表示该图共有 *N* 个结点和 *M* 条无向边。
>
> 接下来 *M* 行每行包含三个整数 *X**i*,*Y**i*,*Z**i*，表示有一条长度为 *Z**i* 的无向边连接结点 *X**i*,*Y**i*。
>
> **输出格式**
>
> 如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 `orz`。

直接看代码实现:

```cpp
int fa[maxn];

struct Edge
{
    int u,v,w;
};
vector<Edge>edge;
bool cmp(Edge a,Edge b)
{
    return a.w<b.w;
}

int find(int x)
{
    if(fa[x]==x)
    return x;
    else
    return fa[x]=find(fa[x]);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++)
    fa[i]=i;
    for(int i=1;i<=m;i++) //输入数据
    {
        int u,v,w;cin>>u>>v>>w;
        edge.push_back({u,v,w});
    }
    sort(edge.begin(),edge.end(),cmp);
    int ans=0,cnt=n;
    for(auto x:edge) //遍历数组
    {
        int xu=find(x.u);
        int xv=find(x.v);
        if(xu!=xv)
        {
            fa[xu]=xv; //合并的时候千万别又忘了
            cnt--;	   //xu,xv是x.uyx.v的根节点
            ans+=x.w;
        }
        if(cnt==1)
        break;
    }
    if(cnt!=1)
    cout<<"orz";
    else
    cout<<ans;

    return 0;
}
```



