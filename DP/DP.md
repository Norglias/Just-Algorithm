## DP

### 1.数的划分(P1025)

**动态规划方程:**

f\[i][x]=f\[i-1][x-1]+f\[i-x][x]

其中i表示数字n,x表示分为了几部分

**方程含义**

第一部分表示: 分组中存在1的情况

第二部分表示: 不存在1的情况

> 这里第二部分的表示值得仔细推敲(即把所有分组的元素-1)

*这他妈根本不是人能想出来的*

代码实现:

```c++
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <string>
#include <math.h>
#include <iostream>
#include <vector>

using namespace std;
int dp[200][20];

int main()
{
   int k,n;
   cin>>n>>k;
   dp[1][1]=1;
   for (int i = 2; i <= n; i++)
   {
      for (int j = 1; j <= k; j++)
      {
         if (i>j)
         {
            dp[i][j]+=dp[i-1][j-1]+dp[i-j][j];
         }
         else if(i==j)
         {
            dp[i][j]=1;
         }
         else
         {
            dp[i][j]=0;
         }
      }
      
   }
   cout<<dp[n][k];
}
```



### 2.栈(P1044)

>  此题可用卡特兰数秒了

> **问题**：有 $n$ 个元素依次进栈（1, 2, 3... n），在进栈的过程中可以随时出栈。求有多少种不同的出栈序列？
>
> **例子**：$n=3$ (进栈 1,2,3)，合法出栈有：`123`, `132`, `213`, `231`, `321` (共 5 种)。`312` 是非法的。



我们可以定义 **dp~i,j~** 状态

i表示没有入栈的元素, j表示栈中当前的元素数

可有

```c++
for(int i=0;i<=n;i++)
dp[0][i]=1;
```

表示没有元素需要入栈的情况

有动态规划方程

```c++
dp[i][j]=dp[i-1][j+1]+dp[i][j-1] //j不等于0,表示出栈的情况数加上入栈的情况数
dp[i][j]=dp[i-1][j+1]			 //j等于0,只能入栈
```

**代码实现:**

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int dp[100][100];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=0;i<=n;i++)
    dp[0][i]=1;
    
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=n;j++)
        {
            if(j)
            dp[i][j]=dp[i-1][j+1]+dp[i][j-1];
            else
            dp[i][j]=dp[i-1][j+1];
        }
    }

    cout<<dp[n][0];   
    return 0;
}
```



### 3.线性DP

#### 1.最长上升子序列 (LIS) 

> 求最长上升子序列的基本模板就是:
>
> *从数列 a 中任意删除若干个整数，构造一个单调递增的数列。请求出该单调递增数列的最大可能长度。*

假设我们有一个序列 `a = [10, 9, 2, 5, 3, 7, 101, 18]`

使用dp时, 其中`dp[i]`代表以` a[i]`结尾的最长上升子序列的长度

初始化时需要把所有`dp[i]`初始化为1 (以自身为长度)

通过 $O(n^2)$ 的嵌套循环寻找比`a[i]`小的数, 找到就在dp后加个一

```c++
int ans=0;
for(int i=0;i<n;i++)
{
    for(int j=0;j<i;j++)
    {
        if(a[j]<a[i]) //说明a[i]可以接在a[j]后面形成上升序列
        {
            dp[i]=max(dp[i],dp[j]+1)
        }
    }
    ans=max(ans,dp[i]); //全局最大值就是答案
}
```



当然这种 $O(n^2)$ 的做法很容易超时, 

优化的方法就是使用 **贪心+二分查找** 可以优化时间复杂度到$O(n \log n)$









### 4.背包DP(P1048)

背包DP, 线性DP的一种特殊情况, 用于解决**在资源有限的情况下，如何选择能利益最大化**的问题

最基础的就是给出各个物品的价值以及选择的限制, 问如何达到利益最大化

> **P1048**
>
> **题目描述**
>
> 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
>
> 如果你是辰辰，你能完成这个任务吗？
>
> **输入格式**
>
> 第一行有 2 个整数 *T*（1≤*T*≤1000）和 *M*（1≤*M*≤100），用一个空格隔开，*T* 代表总共能够用来采药的时间，*M* 代表山洞里的草药的数目。
>
> 接下来的 *M* 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。
>
> **输出格式**
>
> 输出在规定的时间内可以采到的草药的最大总价值。

定义$dp[j]$为当背包容量(采摘时间)为 j 时, 能装下的最大价值 

对于每一件物品, 有转移方程:

$$dp[j] = \max(dp[j], \quad dp[j - w] + v)$$

其中w表示时间, v表示价值

逻辑理解就是某一次可以选择**不拿**或者**拿走, 背包容量减少**

**01背包具体实现:**

```c++
int t,m;cin>>t>>m;
    vector<pair<int,int>>qwq;
    for(int i=1;i<=m;i++)
    {
        int x,y;cin>>x>>y;
        qwq.push_back({x,y});
    }
    int sum=0;
    for(int i=0;i<m;i++)
    {
        int time=qwq[i].first,v=qwq[i].second;
        for(int j=t;j>=time;j--)//关键逻辑,倒序遍历背包容量,这是01背包题的特性
        dp[j]=max(dp[j],dp[j-time]+v);
    }
    cout<<dp[t];
```

如果是**完全背包** (即可以无限次拿某一个物品)

把内层循环改为**正序**就行了

